package com.newcoder.zuo3.advanced.class08;

public class Code_01_ShuffleProblem {
    //完美洗牌问题
    //有一个长度为偶数的数组arr， 左边一半叫做左半区， 右边一半叫做右半区。
    //记为：
    //[L1,L2,...,LK,R1,R2,...,RK]
    //请调整成
    //[L1,R1,L2,R2,...,LK,RK]
    //比如
    //[1,2,3,4]调整成[1,3,2,4]
    //[1,2,3,4,5,6]调整成[1,4,2,5,3,6]
    //要求： 时间复杂度O(N)， 额外空间复杂度O(1)

    //下标循环怼:每一个下标都知道自己下一步要去哪,
    // 所以拿出一个下标怼出它要去位置上已有的下标然后这个下标再去找它应该去的位置,
    // 这么循环往复,直到所有下标都找到自己应该在的位置,但是这样有一个问题,
    // 下标的怼实际上是一个一个独立出来的小环,如果每一个都遍历,有的位置就怼回去了,
    // 所以有如下结论;长度满足(3^k)-1时,触发点下标为从1到
    // (如果数组长度为2,则下标为1,2而不是0,1)3^(k-1),例:长度为(3^2)-1=8时,有触发点下标1,3^(2-1) = 3,k从1开始
    //如果长度不是正好在(3^k)-1上该怎么办:拆成满足条件的块

    public static void shuffle(int[] arr, int l, int r) {
        //找最大的块

    }
}
